{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)d2a59d60-9351-44eb-8889-f883ec3c7c98","ParentGuid":"(Guid)c6490cda-40b4-40bf-aca3-a5070b47f989","Name":"(string)Init_Master","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)5cb5d7a8-b23e-4447-9125-088556e37dbd"}]}}}}]},"TypeGuid":"(Guid)8ac092e5-3128-4e26-9e7e-11016c6684f2","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"8ac092e5","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//--- System generated code, could be modified for your application ---------------------------------------------------------\n\n//--- Standard interface ---------------------------------------------------------\n\t//\n\tastSubModuleInterface[c_udiMaster].i_sModuleName\t:= STANDARD.CONCAT(STR1 := iq_stStandardModuleItf.i_sModuleName, STR2 := ': Master');\n\t\n\tastSubModuleInterface[c_udiMaster].i_xLogEnable\t\t:= TRUE;\n\tastSubModuleInterface[c_udiMaster].i_wLogDataFilter\t:= UDINT_TO_WORD(TPL.ET_LogDataFilter.ModuleDefault);\n\t\n\tfbMasterModule.RegisterLoggerPoint(\ti_ifParent\t:= fbLoggerPoint,\n\t\t\t\t\t\t\t\t\t\ti_sName\t\t:= 'Master',\n\t\t\t\t\t\t\t\t\t\tq_etDiag\t:= ,\n\t\t\t\t\t\t\t\t\t\tq_etDiagExt\t:= );\n\n//\n//--- Master, Drive& LEnc ---------------------------------------------------------\n\t//\n\tstMasterInterface.stMain.i_ifMaster\t\t:= i_ifMaster; \t\t(* Master *)\n\tstMasterInterface.stMain.i_ifDrive\t\t:= DRV_Master;\n\tstMasterInterface.stMain.iq_lencEncoder\t:= LE_Master;\t\n//\n//--- Check if Drive is virtual ---------------------------------------------------------\n\t//\n\txDriveIsVirtual := FC_IsDriveVirtual(\ti_ifDrive\t:= stMasterInterface.stMain.i_ifDrive,\n\t\t\t\t\t\t\t\t\t\t\tq_etDiag\t=> etDiag,\n\t\t\t\t\t\t\t\t\t\t\tq_etDiagExt\t=> etDiagExt,\n\t\t\t\t\t\t\t\t\t\t\tq_sMsg\t\t=> sMsgBuffer);\n\t\n\tIF etDiag <> GD.ET_Diag.Ok AND NOT xIsDriveVirtualException THEN\t\t\t\t\t\t\t\t\t\t\n\t\tstIsDriveVirtualException.etDiag \t:= etDiag;\n\t\tstIsDriveVirtualException.udiDiagExt:= etDiagExt;\n\t\tstIsDriveVirtualException.sDiagExt \t:= FC_EtDiagExtToString(etDiagExt);\t\t\t\t\t\t\t\t\t\t\n\t\tstIsDriveVirtualException.sMsg \t\t:= sMsgBuffer;\n\t\txIsDriveVirtualException \t\t\t:= TRUE;\n\tEND_IF\n\t\n\tfbExceptionHandler.SetException(i_xExceptionActive\t:= xIsDriveVirtualException, \n\t\t\t\t\t\t\t\t\tiq_stException\t\t:= stIsDriveVirtualException, \n\t\t\t\t\t\t\t\t\tiq_stExceptionList\t:= iq_stExceptionList);\n\t\t\t\t\t\t\n\txInitSuccessful := xInitSuccessful AND NOT xIsDriveVirtualException;\n\tetDiag := GD.ET_Diag.Ok;\n\t\n//\n//--- Set DeadTime compensation parameters depending on used type of Master ---------------------------------------------------------\n\tFC_SetDeadTimeCompensation(i_stSubModuleInterfaceMain := stMasterInterface.stMain);\n\n//\n//--- Set Velocity Parameters ---------------------------------------------------------\n\tstMasterInterface.stMain.i_lrMotionActiveVelLimit\t\t\t\t\t\t:= 15.0;\t\t(* Limit for max. velocity of astAxisModuleInterface to switch output AxisMove in Units/s *)\n\tstMasterInterface.stMain.i_etMotionActiveVelType\t\t\t\t\t\t:= AXM.ET_MotionActiveVelType.Velocity;\n\t\n\tstMasterInterface.stMain.stReducedVelocity.i_xEnableReducedVelocity\t\t:= FALSE;\n\tstMasterInterface.stMain.stReducedVelocity.i_xOnlyLimitCheck\t\t\t:= FALSE;\n\tstMasterInterface.stMain.stReducedVelocity.i_lrMaxReducedVelocity\t\t:= 50.0;\n//\n//--- Stop Parameters ---------------------------------------------------------\n\tstMasterInterface.stMain.i_timMasterStop\t\t\t\t\t\t\t\t:= T#1S;\n\tstMasterInterface.stMain.i_xHwLimitPos\t\t\t\t\t\t\t\t\t:= FALSE;\n\tstMasterInterface.stMain.i_xHwLimitNeg\t\t\t\t\t\t\t\t\t:= FALSE;\n\t\n\t\n\tstMasterInterface.stMain.i_xStart\t\t\t\t\t\t\t\t\t\t:= FALSE;\n\n//\n//--- Set Homing Mode ---------------------------------------------------------\n\t//\n\tIF xDriveIsVirtual THEN\n\t\tstMasterInterface.stHome.i_etMode := PDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition;\t\t(* Homing Mode in case of virtual axis *)\n\tELSE\n\t\tstMasterInterface.stHome.i_etMode := PDL.ET_HomeMode.PosDirectionPosEdgeTp;\t\t\t\t\t(* Homing Mode in case of real axis *)\n\tEND_IF\n\n\n\tstMasterInterface.stHome.i_xEnableInitAbsReadPos := FALSE;\t\t\t\t\t\t(* TRUE : Restores the AxisPosition depending on the stHome.etMode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  If stHome.i_etMode is equal to PDL.ET_HomeMode.RestorePosFromAxisEncoder or \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  to PDL.ET_HomeMode.WriteAxisEncoder, the encoder of the axis is read,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  or else the position will be restored from the retain area *)\n\t\n\tstMasterInterface.stHome.stSetpos.iq_pstRestorePosRetain := ADR(Grp_stRestorePositionAxis1);\n\t\n\tstMasterInterface.stHome.i_xResetHomeOk := FALSE;\n\n//\n//--- Homing mode Sensor:\n\t(*\tPDL.ET_HomeMode.PosDirectionPosEdgeSensor\n\t\tPDL.ET_HomeMode.NegDirectionPosEdgeSensor\n\t\tPDL.ET_HomeMode.NegDirectionNegEdgeSensor\n\t\tPDL.ET_HomeMode.PosDirectionNegEdgeSensor\t*)\n\n\tstMasterInterface.stHome.stSensor.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stSensor.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stSensor.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\n\tstMasterInterface.stHome.stSensor.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\n\tstMasterInterface.stHome.stSensor.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\n\tstMasterInterface.stHome.stSensor.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\n\tstMasterInterface.stHome.stSensor.i_lrMaxTravel \t\t\t:= 720.0;\t\t(* Max. travel for referencing by normal input *)\n\tstMasterInterface.stHome.stSensor.i_xRotativeSystem\t\t\t:= FALSE;\t\t(* Rotative system true or false for referencing by normal input *)\n\tstMasterInterface.stHome.stSensor.i_xSensor \t\t\t\t:= FALSE;\t\t(* Input for home signal. Can be a signal from a controller input. Has to be written cyclic. *)\n\n//--- Homing mode LimitSwitch:\n\t(* Possible Modes for homing mode LimitSwitch:\n\t\tPDL.ET_HomeMode.PosDirectionPosEdgeHWLimitPos\t\tnormally open contact / Closing contact\n\t\tPDL.ET_HomeMode.NegDirectionPosEdgeHWLimitNeg\t\tnormally open contact / Closing contact\n\t\tPDL.ET_HomeMode.NegDirectionNegEdgeHWLimitNeg\t\tnormally closed contact / Opening contact  \n\t\tPDL.ET_HomeMode.PosDirectionNegEdgeHWLimitPos\t\tnormally closed contact / Opening contact \n\t*)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrHomePosition \t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrLowVel\t\t\t:= 5.0;\t\t\t(* Homing low ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrOffset\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\n\tstMasterInterface.stHome.stLimitSwitch.i_lrMaxTravel \t\t:= 9999.0;\t\t(* Max. travel for referencing normal input as a hardware limit *)\n\n//--- Homing mode MoveOnPos:\n\t(* Possible modes for homing mode MoveOnPos:\n\t\tPDL.ET_HomeMode.MoveOnPosAbs \n\t*)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrTarget\t\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\n\tstMasterInterface.stHome.stMoveOnPos.i_lrPeriod\t\t\t\t:= 0.0;\t\t\t(* Period of the axis *)\n\tstMasterInterface.stHome.stMoveOnPos.i_xRotativeSystem\t\t:= FALSE;\t\t(* Rotative system true or false *)\n\n//--- Homing mode SetPos:\n\t(* Possible modes for homing mode SetPos:\n\t\tPDL.ET_HomeMode.SetPosAxisPosition \n\t\tPDL.ET_HomeMode.SetPosLogEncoderPosition \n\t\tPDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition\n\t\tPDL.ET_HomeMode.RestorePosFromAxisEncoder \n\t\tPDL.ET_HomeMode.RestorePosFromRetain \n\t*)\n\tstMasterInterface.stHome.stSetpos.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stSetpos.i_lrEncoderPosition\t\t:= 0.0;\t\t\t(* Encoder position in units after homing *)\n\tstMasterInterface.stHome.stSetpos.i_lrAbsEncOffset\t\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\n\tstMasterInterface.stHome.stSetpos.i_lrRestoreWindow\t\t\t:= 180;\t\t\t(* How far can the drive be away from its correct position *)\n\tstMasterInterface.stHome.stSetpos.i_lrUserPeriod\t\t\t:= 360;\t\t\t(* Period of the axis *)\n\n//--- Homing mode Torque:\n\t(* Possible modes for homing mode Torque:\n\t\tPDL.ET_HomeMode.PosDirectionMaxTorque \n\t\tPDL.ET_HomeMode.NegDirectionMaxTorque \n\t*)\n\tstMasterInterface.stHome.stTorque.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stTorque.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stTorque.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\n\tstMasterInterface.stHome.stTorque.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\n\tstMasterInterface.stHome.stTorque.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\n\tstMasterInterface.stHome.stTorque.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\n\tstMasterInterface.stHome.stTorque.i_lrMaxTravel\t\t\t\t:= 9999.0;\t\t(* Max. travel for referencing by torque *)\n\tstMasterInterface.stHome.stTorque.i_lrMaxTorque\t\t\t\t:= 0.0;\t\t\t(* Torque for stop in Nm / referencing by torque *)\n\tstMasterInterface.stHome.stTorque.i_diTorqueTime\t\t\t:= 5;\t\t\t(* Time in msec to hold torque *)\n\n//--- Homing mode TouchProbe:\n\t(* Possible modes for homing mode TouchProbe:\n\t\tPDL.ET_HomeMode.PosDirectionPosEdgeTp \n\t\tPDL.ET_HomeMode.NegDirectionPosEdgeTp \n\t\tPDL.ET_HomeMode.NegDirectionNegEdgeTp \n\t\tPDL.ET_HomeMode.PosDirectionNegEdgeTp \n\t*)\n\tstMasterInterface.stHome.stTouchProbe.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrVel\t\t\t\t:= 100.0;\t\t(* Homing ceiling velocity in units/s *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrOffset\t\t\t:= 30.0;\t\t(* Offset from home signal in units *)\n\tstMasterInterface.stHome.stTouchProbe.i_lrMaxTravel\t\t\t:= 720.0;\t\t(* Max. travel for referencing by TP *)\n\tstMasterInterface.stHome.stTouchProbe.i_xRotativeSystem\t\t:= TRUE;\t\t(* Rotative system true or false for referencing by TP *)\n\tstMasterInterface.stHome.stTouchProbe.i_ifTouchProbe\t\t:= TP_0;\t\t(* Input for TP *)\n\n//--- Homing mode WritePos:\n\t(* Possible modes for homing mode WritePos:\n\t\tPDL.ET_HomeMode.WriteAxisEncoder \n\t*)\n\tstMasterInterface.stHome.stWritePos.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\n\tstMasterInterface.stHome.stWritePos.i_lrUserPeriod\t\t\t:= 0.0;\t\t\t(* Calculates Drive.Position into period ( units ) *)\n\tstMasterInterface.stHome.stWritePos.i_lrAbsEncOffset\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\n\n//\n//--- Manual ---------------------------------------------------------\n\t//\n\tstMasterInterface.stManual.i_lrVel\t\t\t\t\t\t\t\t:= 50.0;\t\t\t(* Velocity in units/s *)\n\tstMasterInterface.stManual.i_lrAcc\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Acceleration in units/s^2 *)\n\tstMasterInterface.stManual.i_lrDec\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Deceleration in units/s^2 *)\n\tstMasterInterface.stManual.i_lrJerk\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Jerk in units/s^3 *)\n\tstMasterInterface.stManual.i_lrMaxDistance\t\t\t\t\t\t:= 120.0;\t\t\t(* Max pathlengths for one step in units *)\n\tstMasterInterface.stManual.i_xEndless\t\t\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: jogging endless; Position between the periode; FALSE: jogging in steps. Position can be out of periode *)\n\tstMasterInterface.stManual.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period of the axis *)\n\n//\n//--- Cam ---------------------------------------------------------\n\t//\n\tstMasterInterface.stMultiCam.i_etCSModeSlave\t\t\t\t\t:= PDL.ET_MultiCamCsModeSlave.SetSlavePositionToFirstCamPosition;\t\t(* ColdStartMode Slave *)\n\tstMasterInterface.stMultiCam.i_etCSModeMaster\t\t\t\t\t:= PDL.ET_MultiCamCsModeMaster.SetMasterPositionToFirstCamPosition;\t\t(* ColdStartMode Master *)\n\tstMasterInterface.stMultiCam.i_etWSMode\t\t\t\t\t\t\t:= PDL.ET_MultiCamWsMode.StoredCamMoveAlwaysNoPositionCheck;\t\t\t(* WarmStartMode *)\n\tstMasterInterface.stMultiCam.i_lrWSWindow\t\t\t\t\t\t:= 5.0;\t\t\t\t\t\t\t\t\t\t\t(* WarmStartWindow in Axis units *)\n\tstMasterInterface.stMultiCam.i_lrWSVel\t\t\t\t\t\t\t:= 10.0;\t\t\t\t\t\t\t\t\t\t(* Velocity for WarmStart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s *)\n\tstMasterInterface.stMultiCam.i_lrWSAcc\t\t\t\t\t\t\t:= 1000.0;\t\t\t\t\t\t\t\t\t\t(* Acceleration and deceleration for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s^2 *)\n\tstMasterInterface.stMultiCam.i_lrWSJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t\t\t\t\t\t\t\t(* Jerk for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in units/s^3 *)\n\tstMasterInterface.stMultiCam.i_diTXend\t\t\t\t\t\t\t:= 2*SYSTEMINTERFACE.FC_LzsTaskGetInterval();\t(* Time of XLowEnd and XHighEnd befor Xend or Xstart in msec*)\n\tstMasterInterface.stMultiCam.i_lrInstantXLimMax\t\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Switch off position at 'InstantNewCam' *)\n\t\n\tstMasterInterface.stMultiCam.i_xEnableTabHandler\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: TabHandler is enabled *)\n\tstMasterInterface.stMultiCam.i_udiTableSelectNr\t\t\t\t\t:= AXM.ET_ParId.User;\t\t\t\t\t\t\t(* Number of table which is used in the next cycle *)\t\t\t\t\t\t\t\t\n\t\n\tstMasterInterface.stMultiCam.i_xSetEncoderParameters\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: The parameters MasterId, FeedConstand, GearIn and GearOut will be copyed into LEnc object *)\n\tstMasterInterface.stMultiCam.i_xSetEncoderPosition\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Manipulation of LEnc object on startup OpMode MultiCam *)\n\tstMasterInterface.stMultiCam.i_lrSetEncoderOffset\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Master encoder offset *)\n\tstMasterInterface.stMultiCam.i_xCheckEncoderPeriod\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Check of encoder period = 0. If encoder period <> 0 -> Exception *)\n\t\n\t// stMasterInterface.stMultiCam.iq_xNewCam\t\t\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: A new DataStruct will be load for next cycle. Will be reset when new cycle is started in case of stMultiCam.i_xEnableTabHandler = FALSE. *)\n\t// stMasterInterface.stMultiCam.iq_xInstantNewCam\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: A new DataStruct will be load. It will be active at master position stMultiCam.i_lrInstantXLimMax. Will be reset when ne DataStruct is active *)\n\t// stMasterInterface.stMultiCam.iq_xChangeMaster\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Switch to a new Master. Will be reset when done. *)\t\t\t\n\t\n\t// stMasterInterface.stMultiCam.iq_stExt\t\t;\t\t\t\t\t\t(* Extended In of the Multicam FB, can be used if needed! *)\n\t\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diNumberOfCamPoints\t\t\t:= 4;\t(* DataStruct for the next cycle *)\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].lrYPeriod\t\t\t\t\t:= 0.0;\n\t\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrX\t\t\t:= 0.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrY\t\t\t:= 0.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrM\t\t\t:= 0.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrX\t\t\t:= 60.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrY\t\t\t:= 30.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrM\t\t\t:= 1.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].etCamType\t:= PDL.ET_CamType.Straight;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrX\t\t\t:= 240.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrY\t\t\t:= 210.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrM\t\t\t:= 1.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrX\t\t\t:= 360.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrY\t\t\t:= 0.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrM\t\t\t:= 0.0;\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\t\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Idle].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Idle);\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Start].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Start);\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Cont].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Cont);\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Stop].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Stop);\n\tstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.User);\n\t\n\t\n\t//--- ILS Data --------------------------------------------------------\n\t//---\n\t// \tstMasterInterface.stMultiCam.i_udiIlsSlaveNumber\t\t\t\t\t\t\t\t\t\t\t\t\t\t:= 1;\n\t// \t\n\t// \tG_stIlsData.i_stRunTime.astSlaveLimits[stMasterInterface.stMultiCam.i_udiIlsSlaveNumber].lrPosVel\t:= 1000.0;\n\t// \tG_stIlsData.i_stRunTime.astSlaveLimits[stMasterInterface.stMultiCam.i_udiIlsSlaveNumber].lrNegVel\t:= -1000.0;\n\t// \tG_stIlsData.i_stRunTime.astSlaveLimits[stMasterInterface.stMultiCam.i_udiIlsSlaveNumber].lrPosAcc\t:= 10000.0;\n\t// \tG_stIlsData.i_stRunTime.astSlaveLimits[stMasterInterface.stMultiCam.i_udiIlsSlaveNumber].lrNegAcc\t:= -10000.0;\n\t// \t\n\t// \tG_stIlsData.i_astCamData[stMasterInterface.stMultiCam.i_diIlsSlaveNumber].diNumberOfMasterPeriods\t:= 1;\t\n\t// \tG_stIlsData.i_astCamData[stMasterInterface.stMultiCam.i_diIlsSlaveNumber].diMasterPeriodInit\t\t:= 1;\n\t// \tG_stIlsData.i_astCamData[stMasterInterface.stMultiCam.i_diIlsSlaveNumber].lrXOffset\t\t\t\t\t:= 0.0;\n\t// \t\n\t// \tstMasterInterface.stMultiCam.pstIlsData\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:= ADR(G_stIlsData);\n\n//\n//--- Endless ---------------------------------------------------------\n\t//\n\tstMasterInterface.stEndless.i_lrVel\t\t\t\t\t\t\t\t:= 0.0;\t\t\t\t\t(* Velocity in Units/s *)\n\tstMasterInterface.stEndless.i_lrAcc\t\t\t\t\t\t\t\t:= 10_000.0;\t\t\t(* Acceleration in Units/s^2 *)\n\tstMasterInterface.stEndless.i_lrDec\t\t\t\t\t\t\t\t:= 10_000.0;\t\t\t(* Deceleration in Units/s^2 *)\n\tstMasterInterface.stEndless.i_lrJerk\t\t\t\t\t\t\t:= 100_000.0;\t\t\t(* Jerk in units/s^3 *)\n\tstMasterInterface.stEndless.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t\t(* Period one cycle in units *)\n\tstMasterInterface.stEndless.i_lrStopPosition\t\t\t\t\t:= 0.5;\t\t\t\t\t(* Stop position in units *)\n\t\n//--- Endless ILS ---------------------------------------------------------\n\t//\n\t//G_stIlsData.i_stConfig.diNumberOfSlaves\t\t\t\t\t\t\t:= 0;\n\t//G_stIlsData.i_stConfig.diPositionGridSize\t\t\t\t\t\t:= 500;\n\t//G_stIlsData.i_stConfig.diTimeGridSize\t\t\t\t\t\t\t:= 50;\n\t//G_stIlsData.i_stConfig.lrHysteresis\t\t\t\t\t\t\t\t:= 20;\n\t//\n\t//G_stIlsData.i_stRunTime.iMasterAverageVelocityCycles\t\t\t:= 10;\n\t//G_stIlsData.i_stRunTime.lrMasterMaxAbsVel\t\t\t\t\t\t:= 100.0;\n\t//G_stIlsData.i_stRunTime.lrMasterMaxAbsAcc\t\t\t\t\t\t:= 1000.0;\n\t//G_stIlsData.i_stRunTime.lrMasterMaxAbsJerk\t\t\t\t\t\t:= 10000.0;\n\t//G_stIlsData.i_stRunTime.xActivateLimitation\t\t\t\t\t\t:= TRUE;\n\t//\n\t//stSlave1Interface.stEndless.pstIlsData\t\t\t\t\t\t\t:= ADR(G_stIlsData);\n//\n//--- Pos ---------------------------------------------------------\n\t//\n\n\tstMasterInterface.stPos.i_etPosMode\t\t\t\t\t\t\t\t:= SYSTEMINTERFACE.ET_PosMode.Endless;\t\t(* SYSTEMINTERFACE.ET_PosMode.Endless, SYSTEMINTERFACE.ET_PosMode.Relative, SYSTEMINTERFACE.ET_PosMode.Absolute *)\n\tstMasterInterface.stPos.i_lrTarget\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Target position or distance in Units *)\n\tstMasterInterface.stPos.i_lrVel\t\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Ceiling velocity in Units/s *)\n\tstMasterInterface.stPos.i_lrAcc\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Acceleration in Units/s^2 *)\n\tstMasterInterface.stPos.i_lrDec\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Deceleration in Units/s^2 *)\n\tstMasterInterface.stPos.i_lrJerk\t\t\t\t\t\t\t\t:= 36000.0;\t\t\t\t\t\t\t\t\t(* Jerk in units/s^3 *)\n\t\n\t//--- stMasterInterface.stPos.i_xStop\t\t\t\t\t\t\t\t:= FALSE;\n//\n//--- End of system generated code, could be modified for your application ---------------------------------------------------------","LineInfoPersistence":"(string)d2a59d60-9351-44eb-8889-f883ec3c7c98_Impl_LineIds"}}}},"UniqueIdGenerator":"(string)1816"}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","8ac092e5":"{8ac092e5-3128-4e26-9e7e-11016c6684f2}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}